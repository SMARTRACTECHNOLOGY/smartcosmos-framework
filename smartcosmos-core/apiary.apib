FORMAT: 1A
HOST: https://snapbundle.tagdynamics.net

# SnapBundle™ Platform API
![alt text](https://raw2.github.com/snapbundle/sdk/master/images/snapbundle.png "SnapBundle Logo")  
**A platform purposefully built to be an application's contextual data store.**  
  
## Document Status 
This document is a **work in progress**. It only describes the **public facing API** of the platform, as the platform itself is proprietary.

## The SnapBundle Hypothesis
- Every app captures context at some level
- Every app tries to capture metadata, tags, location data, timestamps, files, etc.
- Every app seemingly designs these same patterns _over, and over and over and over…_

SnapBundle was designed as a platform; with minimal effort it can sit atop of other platform services you are already paying 
for, lowering the total cost of adoption.

## What is a _Context_ Data Store?
Every application captures context to some degree. There will always be application specific entities that don't map well into 
the SnapBundle platform. SnapBundle isn't intended to totally eliminate the need for your application to have some type of 
persistence layer. It is, however, intended to compliment that layer by offering *context services*. So how does SnapBundle 
define context?

Context starts the notion of a *thing*. This could be any noun-- think person, place, or (sorry) thing. Every *thing* in your 
system can be described using various types of *characteristics*. These characteristics may be simple, like eye color is blue 
or shape is square, or they may be more advanced, such as a 3D model of a building. Context changes over time, so every 
contextual model must consider both *space and time* (adding that 4th dimension to the mix). Finally, context must include the 
concepts of *relationship* and *interaction*. For example, a person Jason may have a relationship with Foo Bank, and he interacts 
with the bank everytime he makes a deposit or withdrawl. 

A few final noteworthy comments about context. First, relationships are binary in nature; true or false. Either Jason has an 
account with Foo Bank, or he doesn't. There is no inbetween or ambiguity. Second, interactions operate using a "0, 1, or many" 
cardinality. Finally, the notion of a relationship isn't restricted to the traditional "is-a" or "has-a" concepts defined by 
the semantic web. Verbs are valid relationships! *Jason "likes" Meredith* and *Jason "worked on" Air Conditioner* are both 
valid relationships. 

## How SnapBundle Models Context
### Objects
The contextual *thing* we talked about above is simply referred to as an *Object* in SnapBundle. Every Object can be fully 
described using the SnapBundle platform. Take a look at this graphic:

![alt text](https://raw2.github.com/snapbundle/sdk/master/images/object-characteristics.png "Object Characteristics")
  
An Object can use the type-safe key-value pairs of *metadata* to describe characteristics. It can have a relationship with one 
or more geospatial definitions, built using the open [GeoJSON 1.0 Specification](http://geojson.org "GeoJSON Web Site"). 

Today's world has rapidly become smart device driven. Smartphones, tablets, laptops, and even specialized fashion accessories 
like Google Glass and smart watches are both fashion statements and the norm. Every *devices* in SnapBundle is a first-class 
citizen, and possession of a device can be linked to an Object. *Joe "borrowed" iPad* and *Sam "owns" iWatch* are legitimate 
device relationships with an Object.

An Object may be assigned any number of *tags*. Tags are like categories, but they are intended to be much more specific. In the 
blog world, for example, tags are used to create a mini index into a specific blog posting. In contrast, blog categories tend to 
represent a table of contents. Tags are also (typically) intended to be used as they are in Twitter, Facebook, and other social 
media applications.

An Object may be responsible for producing any number of *files*, including pictures, videos, documents, presentations, manuals, 
etc. 

Depending on the type of Object, it may have a *geospatial* relationship that precisely defines the perimeter of a building, 
it could represent a "check-in" at a common location, or it could represent the complete path, including stops, if the Object 
happens to be a delivery driver.

Capturing chronological sequencing is import when dealing with context. Did the Object do A or B first? A *timeline* provides 
a means to capture the chronological history of an Object.

### Relationships
Relationships are a critical component in understanding context. Relationships in SnapBundle are binary in nature, true or 
false, exists or do not exist. 
 
![alt text](https://raw2.github.com/snapbundle/sdk/master/images/relationship.png "Relationship Between 2 Objects")

Modeling relationships with snap bundle is not restricted to the traditional "is-a" or "has-a" concepts commonly associated 
with the semantic web. Relationships may be action verbs to indicate a higher order relationship between two objects. 
Relationships in SnapBundle are not transitive per se. If a object Foo likes object Bar, that doesn't imply that Bar likes Foo. 
In order to capture the transitive nature, a second reciprocal relationship would have to explicitly be defined.

### Interactions
Unlike relationships that are meant to captures a binary existence, an interaction maintains a higher cardinality; they are 
intended to be singular or recurring events.
  
Interactions share the same set of descriptive capabilities found on an Object, as depicted below.

![alt text](https://raw2.github.com/snapbundle/sdk/master/images/interaction.png "Interaction Between 2 Objects")

Check out our [primary data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Primary Data Types") to see 
our incredibly intuitive object model.

### A Contextual Illustration
Consider the following arbitrary example. Jason, a person, is represented as an Object in the system. He has metadata that 
describes his stature, files that contain pictures of him, etc. 

Jeep Rubicon, a vehicle, is also represent as an Object in the system. It has metadata that describe the vehicle, like color = 
black. It also has a geospatial representation associated with it the accurately defines the perimeter of the vehicle, like its 
wheel base, height, width, etc. 

There is a relationship captures that indicates that Jason "owns" Jeep Rubicon.

A series of interactions are captured to represent each time that Jason drove the Jeep Rubicon. Each interaction captures a 
geospatial object that represents the physical route that Jason followed while driving the vehicle. Since Jason made 3 stops
while he was out, those stops are captured with the timeline. During the drive, Jason had a flat tire, so there is a tag 
"#flat" associated with that interaction. He also filled up with gas before returning home, so another tag "#fillup" is noted.

## What SnapBundle Isn't
### It's About Persistence
As you can see, SnapBundle can easily associate virtually _anything_ with _anything_. Hashtags, key-value metadata, and 
arbitrary files of any type or size are easily associated with an Object or other top level entities. Data is securely stored 
in the Cloud. SnapBundle can capture innate relationships like parent-child, peer and neighbor, and it can equally capture 
actions by or between objects.

### It's not an Analytical Engine
The platform wasn't built to perform Big Data analytics- it was meant to store the data that can be fed into a Big Data 
analytics system. It's a subtle difference that shouldn't be quickly dismissed. There are dozens, if not hundreds of analytical 
and expert systems on the market today. Ask yourself this simple question:

*Where are you going to store the authoritative copy of your raw underlining data?*

If you are searching for a solution to free you from storing your data in a proprietary system, possibly creating some type 
of "vendor lock-in," then SnapBundle is what you are looking for. Using Web Services and JSON, push your authoritative records 
to SnapBundle. Wire up SnapBundle to your current preferred analytics engine. Interested in seeing what this new expert system 
can do with your data? Wire up SnapBundle to push data into that system and give it try! 

## Other Noteworthy Features

### Near Real-Time Integration
We get it- *you* generated the data, *you* want to own the data, and, you want us to push it "over here" in a timely manner. 
That's exactly what the SnapBundle platform can do. Today the platform can push data to any HTTPS end point. As soon as we 
digitally sign and persist the data we just received, we'll push a copy of that data to you using JavaScript Object Notation 
(JSON) as fast as the ether will carry the bits. Check out our [Event Stream](EVENT.md "Event Stream") model to see how easy 
it is to understand the data feed.

### Extension Architecture
The SnapBundle platform was designed from scratch with a plugin model; we call them *extensions*. Remember how we said that 
we aren't an analytical engine? We aren't, but maybe you are. Use any modern language- Python, Ruby, Java, .NET, or anything 
that can talk to us using HTTP and JSON. We built our authorization model around the 
[OAuth 2.0 Specification (RFC 6749)](http://tools.ietf.org/html/rfc6749 "OAuth 2.0 Specification"), and data owners can grant 
you read or write access in a very granular fashion.

## Technical Notes

### RESTful Web Service Architecture
The SnapBundle platform is built around a set of RESTful web service endpoints that use JavaScript Object Notation (JSON) to 
represent state. The platform's RESTful JSON architecture means you can easily adopt the platform using _any_ modern programmaing 
language.

#### Wire Level Format
Requests and responses are always formatted using JavaScript Object Notation (JSON). 

The platform's model is organized around the three foundational entities (*`Objects`, `Relationships`, and `Interactions`*). These
foundational entities rely on supporting entities (*`Users`,`Devices`,`Files`, `Tags`, `Metadata`, and `Geospatial`*) to capture
additional context.

### URNs as Keys
All SnapBundle objects are keyed off of a **UUID**, represented using the standard URN nomenclature for a UUID:  

**urn:uuid:<opaque key>**

> Any API call that requires a `{referenceUrn}` parameter must provide a full URN UUID reference, 
e.g. *urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d*

#### Object URN
The only URN in the entire model that is arbitrarily defined by the developer is the `objectUrn` field for an Object record.

### Error States
The common [HTTP Response Status Codes](https://github.com/for-GET/know-your-http-well/blob/master/status-codes.md) are used.

### Date Format
SnapBundle dates _when represented as a string_ are formatted using **RFC 3339**. All times must be in UTC, e.g.

__2013-07-04T09:00:00-00:00__

#### Use of Unix Time
SnapBundle timestamps are always represented in JSON with a `long` datatype, where the value must be interpretted as a 
[Unix Timestap](http://en.wikipedia.org/wiki/Unix_time "Unix time definiton").

#### Tracking Modification Timestamps
All SnapBundle objects maintain a `lastModifiedTimestamp` field to track when the record was last updated. The purpose of this 
timestamp is to provide a valid eTag for HTTP cache support.

### Moniker: Arbitrary External System Alias
All SnapBundle objects support a `moniker` field that can be used as the developer sees fit. This field is **never** 
interpreted by the platform, and it may be null if the developer chooses not to use it (null is the default value if the 
field is omitted in a **PUT** call).

> The SnapBundle authors promise developers that the platform itself will never rely on the moniker value for any feature, 
now or in the future, leaving it entirely available for 3rd party developers to use as they see fit in their applications.

A popular usage of the `moniker` field is to provide a logical link between an SnapBundle object, say an RFID Object record, 
and some type of proprietary (abstract) key in your back office account, e.g. ADDR-123-43-2013. This could be a link to a 
legacy key, or a JSON or XML stanza for more structure content.

**NOTE:** The `moniker` field is **limited to a maximum of 2048 characters** at this time. If you need more space than that, 
create a **File** and use the moniker to store the file's system-assigned URN.

### JSON Serialization Views
Every **GET** endpoint allows the developer to control the verbosity of the JSON response. Generally, this fact is encapsulated 
and of little concern to most developers. However, it is possible in rare situations to observe the same identical object, as 
indicated by its URN key, serialized with more (or less) fields. The serialization levels supported by the platform include:

   * **Published** - Publicly accessible fields (specific to the Extension Framework)

   * **Minimum** - All Published fields, plus highly pertinent fields

   * **Standard** - [**default**] All Minimum fields, plus additional contextual fields

   * **Full** - All Standard fields, plus fields rarely referenced


   * **Restricted** - Opaque fields accessible only to the SnapBundle platform's cloud-side code and 
   *never transmitted over the wire* under any circumstance. These fields are *never updatable* by the developer. If a `view` 
query parameter is set to **Restricted**, it returns **Standard**.

#### Requesting a Specific Serialization View
Every **GET** endpoint is serialized using the **Standard* JSON view by default, but can be overrode by the developer by 
including a `view` query string parameter set to the case-sensitive name of one of the serialization views.

The query string parameter `view` must be a case-sensitive value matching one of the following: {`Published`, `Minimum`, 
`Standard`, or `Full`}. _Any value outside of this range automatically defaults to `Standard`. 

**NOTE:** The default serialization view for any POST that returns a response is `Standard` and cannot be changed at this time.

## Support
The fastest way to obtain support is by emailing <engineering@tagdynamics.net>.

# Group Registration Endpoints
Every SnapBundle Account belongs to a _security realm_. By default, the registration endpoint will extract the domain name 
from your email address. However, if you are using a popular email service like GMail or Yahoo, you **must** provide a custom 
realm name at registation. Use the **Realm Availability** endpoint to see if your desired realm name is available.   

Once you've identified a realm name, your ready to complete registration. Registering for an SnapBundle Account and then 
confirming the email address associated with the Account registration are the only perquisites for using the platform. These 
two steps are required before any endpoints that require authentication can be successfully accessed.

## Understanding Realms
The SnapBundle™ platform is a multi-tenant system by design. Each Account operates within its own _security realm_ in order 
to keep one Account's data separate from another Account's data. By default, the security realm is established _based on the 
Account registration email address' top level domain_. For example, registering for an Account with the email address 
developer@tagdynamics.com would result in the automatic assignment of the _tagdynamics.com_ realm, if it is available. It is 
possible to override this default behavior by including a _realm_ attribute in the JSON document submitted to the registration 
endpoint.

> If you are an Individual or a Developer registering with a popular email address from say yahoo.com, gmail.com, etc. then 
it is strongly recommended that you register using a unique, custom realm. This approach will allow the use of a individual 
email, e.g. you@yahoo.com, even though a realm like yahoo.com is prohibited. If you are an Enterprise, it is strongly 
recommended you omit the realm, which will automatically register your email address domain as your realm.

## Realm Availability [/registration/realm/{realm}]
### Check to see if the named realm is available for registration [GET]

+ Parameters
    + realm (required, string, `foo.com`) ... Check to see if the named realm is available for registration

+ Response 200 (application/json)

            {
                "code": 0,
                "message" : "foo.com"
            }

## Account Registration [/registration/register]
### Register for a new SnapBundle account [POST]

+ Request (application/json)

            {
                "emailAddress": "you@foo.com",
                "realm" : "foobar.com"
            }

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : RegistrationRequest, AccountDefined
            
    + Body
    
            {
                "urn" : "urn:uuid:64618d0b-3b8c-456a-87d0-31bc1a0bc579",
                "lastModifiedTimestamp" : 1382828220349,
                "emailAddress" : "you@foo.com",
                "realm" : "foo.com",
            }

# Group Account Management Endpoints

An _Account_ record is created automatically at the time of _registration confirmation_ (not at the time of registration), 
along with your administrator User record. The Account record holds your account _name_, and _description_.

## Account Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
name | String  | true | true | Minimum | 
description | String  | false | true | Standard | 
activeFlag | Boolean  | true | false | Standard  | 

## Password Self-Service
The platform offers two endpoints for password self-service, supporting both password change and password reset.

## Account Details [/account{?view}]
### Lookup my account details [GET]

+ Parameters
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : AccountAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
                "urn" : "urn:uuid:1234567890",
                "lastModifiedTimestamp" : 12345,
                "name" : "Foo",
                "description" : "Bar",
                "activeFlag" : true
            }

## Change Your Password [/account/password/change]
### Change the authenticated user's password, presuming they know their existing password to change to a new password. [POST]

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
    + Body
    
            {
                "oldPassword" : "0lDs3cr3t!",
                "newPassword" : "N3ws3cr3t?"
            }

+ Response 200 (application/json)

    + Headers
    
            SnapBundle-Event : UserPasswordChanged
            
    + Body
    
            {
                "code" : 1,
                "message": "Password successfully changed"
            }

## Reset Lost Password [/account/password/reset]
### Trigger a password reset workflow via email for the specified Account associated with the indicated email address. [POST]

+ Request (application/json)
    
            {
                "emailAddress" : "you@foo.com"
            }

+ Response 200 (application/json)

    + Headers
    
            SnapBundle-Event : UserPasswordReset
            
    + Body   
    
            {
                "code" : 1,
                "message": "Password reset email has been sent"
            }

# Group User Endpoints
## User Endpoint Security
SnapBundle only permits users with a `roleType` of **Administrator** to set or reset other user account passwords.

## Overview
The initial registration account is automatically defined with a `roleType` of **Administrator**. Additional users can be
created using any valid email address.

### SnapBundle is not a directory service
The only metadata collected about a user includes first name, last name, email address, and role type. The use of the email
address is expected to provide a suitable means of identification of an actual user within the account.

The platform's default directory service plugin relies on the [Stormpath](http://stormpath.com "Stormpath Web Site")
authentication and authorization PaaS as its default directory service provider. **This means that SnapBundle doesn't manage
any user credentials, delegating all of this responsibility to Stormpath.**

Direct access to an account's Stormpath data is prohibited. For example, password self-service is only accessible via the
SnapBundle Account Management self-service endpoints.

**It is impossible to retrieve credentials through the API since it is neither stored nor managed by SnapBundle**.

## User Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | fase | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
emailAddress | String  | true | false | Minimum |
givenName | String | false | true | Full | null
surname | String | false | true | Full | null
roleType | RoleType  | true  | true | Minimum | User

### Field Notes
- The `roleType` field is used as a security filter that may restrict the user from certain sensitive operations
*in future API versions*. The only supported values at this time are *Administrator* and *User*.

## User Management [/users]
### Create a new user associated with the specified email address   [PUT]

The following user fields may be used to create a new record:

- `emailAddress` is required and constrained to 128 characters
- `roleType` is required and constrained to the case-sensitive values of **Administrator** or **User**
- `givenName` is optional and constrained to 50 characters and defaults to **null**
- `surname` is optional and constrained to 50 characters; it defaults to **null**
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

#### Idempotent Behavior
This endpoint is idempotent and will respond with an appropriate HTTP status code to indicate the actual result

- **201 SUCCESS_CREATED** if the record is new
- **200 SUCCESS_OK** if a User with the given `emailAddress` already existed in the database, in which
case **no data is merged; existing record is left as-is**

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

    + Body

            {
                "emailAddress": "coworker@foo.com",
                "roleType": "User"
            }

+ Response 201 (application/json)

    + Headers

            SnapBundle-Event : UserDefined

    + Body

            {
                "code" : 1,
                "message" : "r@nd0mP@ssword!"
            }

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : UserAccessed

    + Body

            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }

+ Response 400 (application/json)

    + Body

            {
                "code" : -5,
                "message" : "JSON is missing a required field: emailAddress"
            }


### Update an existing user [POST]

The request body must include a valid `emailAddress` field. Only those fields being updated need to
be included in the JSON body. For example, if you only want to update the `surname` of the user, only
include that field in the request body.

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

    + Body

            {
                "emailAddress": "coworker@foo.com",
                "givenName": "Homeslice",
                "surname": "Simpson"
            }

+ Response 204

    + Headers

            SnapBundle-Event : UserUpdated


+ Response 400 (application/json)

    + Body

            {
                "code" : -5,
                "message" : "JSON is missing a required field: identification"
            }

## Lookup Specific User by URN [/users/{urn}{?view}]
### Lookup a specific user by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : UserAccessed
            SnapBundle-View : Standard

    + Body

            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "lastModifiedTimestamp" : 1390607277299,
                "emailAddress" : "coworker@foo.com",
                "roleType" : "User"
            }


+ Response 204


## Lookup Specific User by Email Address [/users/user/{emailAddress}{?view}]
### Lookup a specific user by their email address [GET]

+ Parameters
    + emailAddress (required, string, `coworker@foo.com`) ... Exact case-sensitive email address to locate
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : UserAccessed
            SnapBundle-View : Standard

    + Body

            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "lastModifiedTimestamp" : 1390607277299,
                "emailAddress" : "coworker@foo.com",
                "roleType" : "User"
            }

## Change or Reset User Password [/users/user]
### Initiate a reset password workflow or specifically define the user's password [POST]

The request body must include a valid `emailAddress` field. If the body only includes an `emailAddress` then
the password reset workflow will be initiated. However, if the body also includes a `newPassword` field, then
the user's password will be changed to that password.

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

    + Body

            {
                "emailAddress": "coworker@foo.com",
            }

+ Response 200

    + Headers

            SnapBundle-Event : UserPasswordReset

    + Body

            {
                "code" : 1,
                "message" : "Password has been reset"
            }

+ Response 400 (application/json)

    + Body

            {
                "code" : -5,
                "message" : "JSON is missing a required field: emailAddress"
            }

# Group Device Endpoints
## Overview
SnapBundle may be used to capture metadata about devices in order to make the association that _this user used this device_. 
The `identification` field is the most important field in this data type, as it represents the unique identifier of the device. 
On a laptop, this could be the computer's network MAC address, or serial number printed on an asset tag affixed to the computer, 
or on a cell phone it could be the manufacturer's IMEI string or perhaps the phone number.

> SnapBundle makes no inferences from the device identification. Theoretically, an account with 100 devices could simply 
sequence the identification of each device, i.e. 1, 2, 3, etc.

## Device Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | false | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
name | String  | true | true | Minimum | 
description | String  | false | true | Standard | 
activeFlag | Boolean  | true | true | Standard  | true
identification | String | true | false | Minimum |
type | String | true | true | Minimum |  

### Field Notes
- The `identification` key MUST be treated as a unique value within your Account's Device set. Multiple devices with 
identical values is explicitly _not_ supported.
- The `type` field is available to create an ontology or high level categories that can be used to group related devices. 
The platform makes no inferences about this case-sensitive field.

## Device Definitions [/devices]
### Create a new device associated with an arbitrary identification value [PUT]

The following device attributes are used to create a new record:

- `identification` is required and constrained to 255 characters. It is arbitrarily defined by the developer, but a 
consistent approach should be utilized. For example, the device's phone number or IMEI could be used consistently to 
identify a smartphone
- `name` is required and constrained to 255 characters
- `type` is required and constrained to 255 characters. It is arbitrarily defined by the developer; the platform never 
interprets the value stored in this field. It could
be general, like *laptop*, or it could be very specific like *MacBook Pro 15" Laptop*  
- `description` is optional and constrained to 1024 characters and may be omitted; defaults to **null**
- `activeFlag` is optional and may be omitted; defaults to **true**
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

#### Idempotent Behavior
This endpoint is idempotent and will respond with an appropriate HTTP status code to indicate the actual result 

- **201 SUCCESS_CREATED** if the record is new
- **200 SUCCESS_OK** if a Device with the given `identification` already existed in the database, in which case 
**no data is merged; existing record is left as-is**

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "identification": "gqorighfawpftjqevznxclmndaawetha",
                "name": "Jason's Phone",
                "type": "Android"
            }
            
+ Response 201 (application/json)

    + Headers

            SnapBundle-Event : DeviceDefined
            
    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : DeviceAccessed
            
    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }

+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: identification"
            }
            

### Update an existing device [POST]

The request body must include a value in either an `identification` or the `urn` field. Only those fields being updated need to 
be included in the JSON body. For example, if you only want to update the `name` of the device, only include that field in the 
request body.

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "identification": "gqorighfawpftjqevznxclmndaawetha",
                "name": "Jason's New Phone"
            }
            
+ Response 204

    + Headers

            SnapBundle-Event : DeviceUpdated    

            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: identification"
            }
            
## Lookup Specific Device by URN [/devices/{urn}{?view}]
### Lookup a specific device by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : DeviceAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "lastModifiedTimestamp" : 1390607277299,
                "identification" : "gqorighfawpftjqevznxclmndaawetha",
                "name" : "Jason's Phone",
                "description" : null,
                "type" : "Android",
                "activeFlag" : true
            }

+ Response 204 
 
## Lookup Specific Device by Identification [/devices/device/{identification}{?view}]
### Lookup a specific device by its system-assigned URN key [GET]

+ Parameters
    + identification (required, string, `gqorighfawpftjqevznxclmndaawetha`) ... Exact case-sensitive identification value to 
    locate
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : DeviceAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "lastModifiedTimestamp" : 1390607277299,
                "identification" : "gqorighfawpftjqevznxclmndaawetha",
                "name" : "Jason's Phone",
                "description" : null,
                "type" : "Android",
                "activeFlag" : true
            }


## Lookup Devices with Name Pattern [/devices{?nameLike,view}]
### Lookup an array of matching devices [GET]

Call always returns a JSON array, which may be an empty array if no devices are found that match the `nameLike` query parameter.

+ Parameters
    + nameLike (optional, string, `Jaso`) ... A case-sensitive *starts with* string pattern to match against. If omitted, 
    then all records will be returned.
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : DeviceAccessed
            SnapBundle-View : Standard
            
    + Body
    
            [
                {
                    "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                    "lastModifiedTimestamp" : 1390607277299,
                    "identification" : "gqorighfawpftjqevznxclmndaawetha",
                    "name" : "Jason's Phone",
                    "description" : null,
                    "type" : "Android",
                    "activeFlag" : true
                }
            ]

# Group Object Endpoints
## Overview
The platform supports arbitrarily defined object types. This means that the platform makes no assumptions about the composition of an 
object identifier, and the platform _never_ attempts to infer any logic from either the Object's `objectUrn` (developer assigned URN) or 
its arbitarily defined `type` field. To illustrate this concept, an Object could represent a Person, a Bank Account, a vehicle, an animal, 
or even a place (optionally complimented by a geospatial definition to precisely define the place).

## Object Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | fase | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
name | String  | true | true | Minimum | 
description | String  | false | true | Standard | null 
activeFlag | Boolean  | true | true | Standard  | true
objectUrn | String | true | false | Minimum | 
type | String | true | true | Minimum |  

### Field Notes
- The `objectUrn` field is considered the authoritative URN when dealing with objects, although a system-assigned `urn` is still generated. 
The `objectUrn` field must be unique across object records in your account.
- The `type` field is available to create an ontology or high level categories that can be used to group related objects. 
The platform makes no inferences about this case-sensitive field.


## Object Management [/objects]
### Create a new object   [PUT]

The following object fields may be used to create a new record:

- `objectUrn` is required and constrained to 1024 characters 
- `type` is required and constrained to 255 characters
- `name` is required and constrained to 255 characters
- `description` is optional and constrained to 1024 characters and may be omitted; defaults to **null**
- `activeFlag` is optional and may be omitted; defaults to **true**
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

#### Idempotent Behavior
This endpoint is idempotent and will respond with an appropriate HTTP status code to indicate the actual result 

- **201 SUCCESS_CREATED** if the record is new
- **200 SUCCESS_OK** if an Object with the given `objectUrn` already existed in the database, in which 
case **no data is merged; existing record is left as-is**

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "objectUrn": "urn:building:mall:ParadiseValley",
                "type": "Building",
                "name": "Paradise Valley Merchant's Mall"
            }
            
+ Response 201 (application/json)

    + Headers

            SnapBundle-Event : ObjectDefined
            
    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : UserAccessed
            
    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }

+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: objectUrn"
            }

### Update an existing object [POST]

The request body must include a valid `objectUrn` field. Only those fields being updated need to 
be included in the JSON body. For example, if you only want to update the `name` of the object, only 
include that field in the request body.

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "objectUrn": "urn:building:mall:ParadiseValley",
                "name": "Paradise Valley Mercantile Mall"
            }
            
+ Response 204

    + Headers

            SnapBundle-Event : ObjectUpdated    

            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: objectUrn"
            }   
            
## Lookup Specific Object by URN [/objects/{urn}{?view}]
### Lookup a specific object by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "objectUrn": "urn:building:mall:ParadiseValley",
                "type": "Building",
                "name": "Paradise Valley Merchant's Mall",
                "description" : null,
                "activeFlag" : true
                "lastModifiedTimestamp" : 1390607277299,
            }

+ Response 204 
 
## Lookup Object by Object URN [/objects/object/{objectUrn}{?view,exact}]
### Lookup a specific object by their arbitrary developer assigned object URN [GET]

+ Parameters
    + objectUrn (required, string, `urn:building:mall:ParadiseValley`) ... Case-sensitive object URN to locate
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)
    + exact (optional, boolean, `true`) ... Defaults to true; when false, a starts-with search is performed 

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "objectUrn": "urn:building:mall:ParadiseValley",
                "type": "Building",
                "name": "Paradise Valley Merchant's Mall",
                "description" : null,
                "activeFlag" : true
                "lastModifiedTimestamp" : 1390607277299,
            }
            
## Query Objects [/objects{?view,modifiedAfter,monikerLike,nameLike,objectUrnLike,type}]
### Lookup an array of matching objects [GET]

####Additive Nature
Each query string parameter is **AND**ed with other parameters. It is not possible to define a parenthetical or mixed Boolean logic
query at this time.

+ Parameters
    + objectUrnLike (optional, string, `urn:building:mall`) ... Case-sensitive `objectUrn` *starts with* pattern to locate
    + type (optional, string, `Building`) ... Case-sensitive `type` *starts with* pattern to locate
    + nameLike (optional, string, `Paradise`) ... Case-sensitive `name` *starts with* pattern to locate
    + monikerLike (optional, string, `urn:uuid:123`) ... Case-sensitive `moniker` *starts with* pattern to locate
    + modifiedAfter (optional, long, `1390607270000`) ... Locate `lastModifiedTimestamp` values equal to or greater than this
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectAccessed
            SnapBundle-View : Standard
            
    + Body
    
            [
                {
                    "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                    "objectUrn": "urn:building:mall:ParadiseValley",
                    "type": "Building",
                    "name": "Paradise Valley Merchant's Mall",
                    "description" : null,
                    "activeFlag" : true
                    "lastModifiedTimestamp" : 1390607277299,
                }
            ]
            
            
# Group Object Address Endpoints
## Overview
Every SnapBundle `Object` may optionally be linked to a physical address. Addresses are usually broadly defined with the `type` field, 
e.g. _physical_ or _last known_. The difference between object address `type` values is arbitrarily defined by the developer.

**NOTE:** There is no limit on how many different address types an object could be associated with. For example, using the `type` field 
one could define a _physical_ and a _mailing_ record set. Likewise, with the `timestamp` field one could insert multiple addresses, 
capturing a series of addresses visited or even a _last known address_ concept.

The Object Address entry differs with a geospatial entry in that addresses rely on political descriptors, e.g. a city names, instead of a 
latitude and longitude on a map projection. The record types are considered complimentary.  

Incomplete or partial addresses are fully supported by the platform. Only an `objectUrn` and a `type` are required to create an address record.  

## Object Address Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
object | IObject | true | false | Standard |
type | String | true | true | Minimum |  
line1 | String | false | true | Minimum | null
line2 | String | false | true | Minumum | null
city | String | false | true | Minimum | null
stateProvince | String | false | true | Minimum | null
countryAbbreviation | String | false | true | Minimum | null
timestamp | long | false | true | Standard | 0

### Field Notes
- The `type` field is available to create an ontology or high level categories that can be used to group related addresses. 
The platform makes no inferences about this case-sensitive field.

## Object Address Management [/objects/object/{objectUrn}/address]
### Create a new object address   [PUT]

The following object fields may be used to create a new record:

- `objectUrn` is required and constrained to 1024 characters 
- `type` is required and constrained to 255 characters
- `timestamp` is optional and its context is arbitrarily defined by the developer
- `line1` and `line2` are optional and constrained to 1024 characters
- `city` is optional and constrained to 1024 characters
- `stateProvince` is optional and constrained to 50 characters
- `postalCode` is optional and constrained to 20 characters
- `countryAbbreviation` is optional and constrained to 2 characters. Developers MUST use [ISO 3166-1](http://www.iso.org/iso/country_codes "ISO 3166"), 
the internationally recognized standard for country codes.

+ Parameters
    + objectUrn (required, string, `urn:building:mall:ParadiseValley`) ... Case-sensitive object URN to assign the address to

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "type": "Mailing Address",
                "line1": "123 Street",
                "stateProvince" : "CA",
                "countryAbbreviation" : "US"
            }
            
+ Response 201 (application/json)

    + Headers

            SnapBundle-Event : ObjectAddressDefined
            
    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:0c7b4d26-1843-44eb-a134-3fbcbbf0578d"
            }
            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: type"
            }

## Update Specific Object Address [/objects/object/{objectUrn}/address/{urn}]
### Update an existing object address [POST]

The request body only needs to include those fields being updated. For example, if you only want to update 
the `stateProvince` of the object, only include that field in the request body.

+ Parameters
    + objectUrn (required, string, `urn:building:mall:ParadiseValley`) ... Case-sensitive object URN that owns the address to update
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "stateProvince": "TX"
            }
            
+ Response 204

    + Headers

            SnapBundle-Event : ObjectAddressUpdated    

            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -2,
                "message" : "No such URN"
            }   
                        
## Lookup Specific Object Address by URN [/objects/object/{objectUrn}/address/{urn}{?view}]
### Lookup a specific object address by its system-assigned URN key [GET]

+ Parameters
    + objectUrn (required, string, `urn:building:mall:ParadiseValley`) ... Case-sensitive object URN that owns the address to update
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectAddressAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
               "city": null,
               "countryAbbreviation": "US",
               "lastModifiedTimestamp": 1390787660961,
               "line1": "123 Street",
               "line2": null,
               "object": {
                  "activeFlag": true,
                  "description": null,
                  "lastModifiedTimestamp": 1390787660901,
                  "name": "foo",
                  "objectUrn": "urn:instagram:FooBar:8fbc1d55-0c3f-461a-ba60-29d7631147fc",
                  "type": "Person",
                  "urn": "urn:uuid:74e9e97a-1f6b-4d38-a12e-a61c42c7c126"
               },
               "postalCode": null,
               "stateProvince": "CA",
               "timestamp": 1390787660961,
               "type": "Mailing",
               "urn": "urn:uuid:0c7b4d26-1843-44eb-a134-3fbcbbf0578d"
            }

+ Response 204 
             
## Lookup Matching Object Addresses by URN [/objects/object/{objectUrn}/address{?view,count}]
### Lookup an array of matching object addresses [GET]

+ Parameters
    + objectUrn (required, string, `urn:building:mall:ParadiseValley`) ... Case-sensitive object URN that owns the address to update
    + count (optional, integer, `1`) ... Maximum number of address records to return; defaults to 1
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectAddressAccessed
            SnapBundle-View : Standard
            
    + Body
    
            [
                {
                   "city": null,
                   "countryAbbreviation": "US",
                   "lastModifiedTimestamp": 1390787660961,
                   "line1": "123 Street",
                   "line2": null,
                   "object": {
                      "activeFlag": true,
                      "description": null,
                      "lastModifiedTimestamp": 1390787660901,
                      "name": "foo",
                      "objectUrn": "urn:instagram:FooBar:8fbc1d55-0c3f-461a-ba60-29d7631147fc",
                      "type": "Person",
                      "urn": "urn:uuid:74e9e97a-1f6b-4d38-a12e-a61c42c7c126"
                   },
                   "postalCode": null,
                   "stateProvince": "CA",
                   "timestamp": 1390787660961,
                   "type": "Mailing",
                   "urn": "urn:uuid:0c7b4d26-1843-44eb-a134-3fbcbbf0578d"
                }
            ]

+ Response 204 


# Group Object Interaction Session Endpoints
## Overview
The Object Interaction Session is used to logically batch together a collection of Object Interaction records. An Object Interaction 
Session is, literally, just a logical grouping construct with a `startTimestamp`, `stopTimestampe`, and arbitrary `type` field to
further describe the type of batch operation. This logical grouping construct conveys that an entire set of Object Interactions occurred
within the context of a *single unit of work*; somehow, all of these Object Interactions are related. What that relationship is should be 
arbitrarily defined by the developer using the `type` field.  
The contents of the `type` field are never evaluated by the platform; it is an external concept. One example use case might be built 
around the concept of reading numerous UHF RFID tags with a specialized RFID scanner.

## Object Interaction Session Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | fase | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
name | String  | true | true | Minimum | 
description | String  | false | true | Standard | null 
activeFlag | Boolean  | true | true | Standard  | true
startTimestamp | long | true | false | Minimum | Generated
stopTimestamp | long | false | true | Minimum | Generated
type | String | true | true | Minimum |  

### Field Notes
- The `startTimestamp` field is system-assigned when the **PUT** call is made.
- The `stopTimestamp` field is system-assigned when the **POST** call is made.
- The `activeFlag` field is system-assigned to `false` when the **POST** call is made.
- The `type` field is available to create an ontology or high level categories that can be used to group related objects. 
The platform makes no inferences about this case-sensitive field.

## Session Management [/sessions]
### Start a new object interaction session   [PUT]

The following fields may be used to create a new record:

- `type` is required and constrained to 255 characters
- `name` is required and constrained to 255 characters
- `description` is optional and constrained to 1024 characters and may be omitted; defaults to **null**
- `activeFlag` is optional and may be omitted; defaults to **true**
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "name": "Daily Tag Scan",
                "type": "RFID Scan"
            }
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : InteractionSessionStart
            SnapBundle-Session-Start : 2013-04-17T09:12:36-00:00
            
    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }
            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: type"
            }

### Stop an existing object interaction session [POST]

The request body must include a valid `objectUrn` field. Only those fields being updated need to 
be included in the JSON body. For example, if you only want to update the `name` of the object, only 
include that field in the request body.

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }
            
+ Response 204

    + Headers

            SnapBundle-Event : InteractionSessionStop
            SnapBundle-Session-Start : 2013-04-17T09:15:23-00:00
            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -11,
                "message" : "session was previously closed"
            }   
            
## Lookup Specific Object Interaction Session by URN [/sessions/{urn}{?view}]
### Lookup a specific session by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectInteractionSessionAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "lastModifiedTimestamp" : 1390607277299,
                "name": "Daily Tag Scan",
                "type": "RFID Scan",
                "description" : null,
                "activeFlag" : true,
                "startTimestamp" : 1390607277299,
                "stopTimestamp" : 0
            }
            
+ Response 204 
 
## Lookup Object Interaction Sessions by Name [/sessions{?view,nameLike}]
### Lookup an array of matching sessions [GET]

+ Parameters
    + nameLike (optional, string, `RFID`) ... A case-sensitive *starts with* string pattern to match against. If omitted, 
    then all records will be returned.
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectInteractionSessionAccessed
            SnapBundle-View : Standard
            
    + Body
    
            [
                {
                    "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                    "lastModifiedTimestamp" : 1390607277299,
                    "name": "Daily Tag Scan",
                    "type": "RFID Scan",
                    "description" : null,
                    "activeFlag" : true,
                    "startTimestamp" : 1390607277299,
                    "stopTimestamp" : 0
                }
            ]
            
+ Response 204 
 
# Group Object Interaction Endpoints
## Overview
The Object Interaction is the major metaphor that the entire platform is effectively designed around. An Object Interaction 
captures context; _this_ Object did _something_ with _that_ object at _this_ time. The interaction is typically decorated with 
additional characteristics, including metadata, tags, geospatial references, etc. 

The primary difference between a _Reference_ and an _Interaction_ is cardinality. Either you are a customer with that bank,
or you aren't a customer- but if you are a customer then each deposit or withdrawl would be a separate interaction. Where
a Reference is treated as a binary relationship (yes or no, true or false), an Interaction is treated as a 0, 1, or many
relationship.

> Every Object Interaction is read-only once submitted! Field values cannot be updated; records cannot be deleted once 
the interaction is persisted by design.

Object Interactions are inherently _bi-temporal_ in nature. There is the time of interaction as captured on a device, perhaps a 
smartphone or laptop, and there is the time of receipt as captured by the platform in the cloud. These two times could have a 
difference of minutes, hours, or perhaps days in those instances where the device lacked an active Internet connection.

## Object Interaction Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | fase | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
entityReferenceType | EntityReferenceType | true | false | Minimum |
referenceURN | String | true | false | Minimum |
object | IObject | true | false | Minimum |
recordedTimestamp | long | true | false | Standard |
receivedTimestamp | long | true | false | Full | Generated
hasSessionMembership | Boolean | true | false | Minimum | Generated
objectInteractionSession | IObjectInteractionSession | false | false | Standard | null

### Field Notes
- The `entityReferenceType` and `referenceURN` fields jointly represent the *owner* or *initiator* of the interaction
- The `recordedTimestamp` field is developer-assigned and identifies the *actual* time of the interaction
- The `receivedTimestamp` field is system-assigned when the **PUT** call is made.
- The `type` field is available to create an ontology or high level categories that can be used to group related interactions. 
The platform makes no inferences about this case-sensitive field.
- The `object` must be defined using the developer-assigned `objectUrn` when issuing a **PUT** call to capture the interaction.


## Interaction Management [/interactions]
### Capture a specific interaction [PUT]

The following interaction fields may be used to create a new record:

- `entityReferenceType` is required and constrained to a valid EntityReferenceType value defined in 
[data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Data Types")
- `referenceURN` must point to a pre-existing record of the given `entityReferenceType`
- `type` is required and constrained to 255 characters
- `recordedTimestamp` is required an must a valid long since the unix epoch
- `objectInteractionSession` is optional and may be omitted; defaults to null. Set value to the system-assigned URN on **PUT** call
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "objectUrn" : "urn:instagram:FooBar:ec3819a1-bc9b-4550-afda-4bd8cbb1dd16",
                "entityReferenceType" : "Object",
                "referenceUrn" : "urn:instagram:FooQux:47c23bc6-2a58-4e37-93b0-848776b42404",
                "recordedTimestamp" : 1390779082039,
                "type" : "Transaction",
            }
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectInteraction

    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8"
            }
            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: type"
            }

## Lookup Matching Interactions [/interactions{?view,objectUrn}]
### Lookup an array of matching interactions [GET]

If no `objectUrn` query parameter is included, then all interactions are returned.

+ Parameters
    + objectUrn (optional, string, `urn:instagram:FooBar:ec3819a1-bc9b-4550-afda-4bd8cbb1dd16`) ... Developer-assigned `objectUrn` to search for
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectInteractionAccessed
            SnapBundle-View : Standard
            
    + Body
    
            [
                {
                   "entityReferenceType": "Object",
                   "hasSessionMembership": false,
                   "lastModifiedTimestamp": 1390779082063,
                   "object": {
                      "activeFlag": true,
                      "description": null,
                      "lastModifiedTimestamp": 1390779081986,
                      "name": "foo",
                      "objectUrn": "urn:instagram:FooBar:ec3819a1-bc9b-4550-afda-4bd8cbb1dd16",
                      "type": "Transaction",
                      "urn": "urn:uuid:ac912b9e-fa52-48e4-a477-aa99f0a2bf92"
                   },
                   "objectInteractionSession": null,
                   "recordedTimestamp": 1390779082039,
                   "referenceURN": "urn:instagram:FooQux:47c23bc6-2a58-4e37-93b0-848776b42404",
                   "urn": "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8"
                }
            ]
            
+ Response 204 


## Lookup Specific Object Interaction by URN [/interactions/{urn}{?view}]
### Lookup a specific interaction by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : ObjectInteractionAccessed
            SnapBundle-View : Standard
            
    + Body
    
            {
               "entityReferenceType": "Object",
               "hasSessionMembership": false,
               "lastModifiedTimestamp": 1390779082063,
               "object": {
                  "activeFlag": true,
                  "description": null,
                  "lastModifiedTimestamp": 1390779081986,
                  "name": "foo",
                  "objectUrn": "urn:instagram:FooBar:ec3819a1-bc9b-4550-afda-4bd8cbb1dd16",
                  "type": "Transaction",
                  "urn": "urn:uuid:ac912b9e-fa52-48e4-a477-aa99f0a2bf92"
               },
               "objectInteractionSession": null,
               "recordedTimestamp": 1390779082039,
               "referenceURN": "urn:instagram:FooQux:47c23bc6-2a58-4e37-93b0-848776b42404",
               "urn": "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8"
            }
            
+ Response 204 

# Group Relationship Endpoints
## Overview
SnapBundle provides a simple, flexible, and incredibly powerful relationship modeling mechanism. The model allows the declaration that
object *A*, for example, could *follows* object *B*. Or, the relationship could be defined where object *A* is a *neighbor* of object
*B*. Verbs are supported as well, such that *a person* *drove* *a car*, where person and car are just Objects with a `type` of person
and car, respectively.

The `relatedEntityReferenceType` and `relatedReferenceUrn` should always be treated as the subordinate object in the relationship that is described by the `relationshipType` field. Consider these examples that illustrate this concept:

`````
Entity Reference Type `Object` identified by Reference URN 1A2B3C has a Child relationship type with Related Entity Reference Type `Object` identified by Reference URN 4D5E6F.
`````

`````
Entity Reference Type `ObjectInteractionSession` identified by Reference URN 1A2B3C has a Child relationship type with Related Entity Reference Type `Device` identified by Reference URN 4D5E6F.
`````

`````
Entity Reference Type `Object` identified by Reference URN 1A2B3C has a Peer relationship type with Related Entity Reference Type `Object` identified by Reference URN 4D5E6F.
`````

The relationship `type` field is used to capture the high level categorization that describes the logical interaction between the two
referenced objects. The platform makes no inferences from any relationships defined.

## Relationship Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | fase | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
entityReferenceType | EntityReferenceType | true | false | Minimum |
referenceURN | String | true | false | Minimum |
type | String | true | false | Minimum |
relatedEntityReferenceType | EntityReferenceType | true | false | Minimum |
relatedReferenceURN | String | true | false | Minimum |

### Field Notes
- The `entityReferenceType` and `referenceURN` fields jointly represent the *owner* or *initiator* of the relationship
- The `relatedEntityReferenceType` and `relatedReferenceURN` fields jointly represent the *subordinate* member of the relationship
- The `type` field is available to create an ontology or high level categories that can be used to group related relationships.
The platform makes no inferences about this case-sensitive field.

## Relationship Management [/relationships/{entityReferenceType}/{referenceUrn}]
### Create a new object   [PUT]

The following object fields are all required to create a new record:

- `entityReferenceType` is required and constrained to a valid EntityReferenceType value defined in
[data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Data Types")
- `referenceURN` must point to a pre-existing record of the given `entityReferenceType`
- `type` is required and constrained to 255 characters
- `relatedEntityReferenceType` is required and constrained to a valid EntityReferenceType value defined in
[data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Data Types")
- `relatedReferenceURN` must point to a pre-existing record of the given `relatedEntityReferenceType`
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

#### Idempotent Behavior
This endpoint is idempotent and will respond with an appropriate HTTP status code to indicate the actual result

- **201 SUCCESS_CREATED** if the record is new
- **200 SUCCESS_OK** if a relationship between the referenced objects already existed in the database, in which
case **the `type` field and `moniker` fields are updated to reflect the values submitted**

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

    + Body

            {
                "type": "Owns",
                "relatedEntityReferenceType": "Object",
                "relatedReferenceURN" : "urn:uuid:54321"
            }

+ Response 201 (application/json)

    + Headers

            SnapBundle-Event : RelationshipDefined

    + Body

            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : RelationshipDefined

    + Body

            {
                "code" : 1,
                "message" : "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d"
            }

+ Response 400 (application/json)

    + Body

            {
                "code" : -8,
                "message" : "No matching record with Object of urn:uuid:12345 exists"
            }

## Relationship Management by URN [/relationships/{urn}{?view}]
### Lookup a specific relationship by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : RelationshipAccessed
            SnapBundle-View : Standard

    + Body

            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "entityReferenceType": "Object",
                "referenceUrn" : "urn:uuid:12345",
                "type" : "Owns",
                "relatedEntityReferenceType": "Object",
                "relatedReferenceURN" : "urn:uuid:54321",
                "lastModifiedTimestamp" : 1390607277299,
            }

+ Response 204

### Deletes an existing relationship by its system-assigned URN key [DELETE]

+ Response 204

    + Headers

            SnapBundle-Event : RelationshipDeleted

## Lookup All Relationships Between Entities [/relationships/{entityReferenceType}/{referenceUrn}/{relatedEntityReferenceType}/{relatedReferenceUrn}{?view}]
### Lookup an array of all defined relationships between any two entities [GET]

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`
    + relatedEntityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + relatedReferenceUrn (required, string, `urn:uuid:54321`) ... Case-sensitive `urn` of an existing entity of type `relatedEntityReferenceType`
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : RelationshipAccessed
            SnapBundle-View : Standard

    + Body

            [
                {
                    "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                    "entityReferenceType": "Object",
                    "referenceUrn" : "urn:uuid:12345",
                    "type" : "Owns",
                    "relatedEntityReferenceType": "Object",
                    "relatedReferenceURN" : "urn:uuid:54321",
                    "lastModifiedTimestamp" : 1390607277299,
                }
            ]

+ Response 204

+ Response 400 (application/json)

    + Body

            {
                "code" : -8,
                "message" : "No matching record with Object of urn:uuid:12345 exists"
            }

## Lookup Specific Relationship Between Entities [/relationships/{entityReferenceType}/{referenceUrn}/{relatedEntityReferenceType}/{relatedReferenceUrn}/{type}{?view}]
### Lookup a specific relationships between any two entities [GET]

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`
    + relatedEntityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + relatedReferenceUrn (required, string, `urn:uuid:54321`) ... Case-sensitive `urn` of an existing entity of type `relatedEntityReferenceType`
    + type (required, string `Owns`) ... Case-sensitive `type` of relationship to look for
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : RelationshipAccessed
            SnapBundle-View : Standard

    + Body

            {
                "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                "entityReferenceType": "Object",
                "referenceUrn" : "urn:uuid:12345",
                "type" : "Owns",
                "relatedEntityReferenceType": "Object",
                "relatedReferenceURN" : "urn:uuid:54321",
                "lastModifiedTimestamp" : 1390607277299,
            }

+ Response 204

+ Response 400 (application/json)

    + Body

            {
                "code" : -8,
                "message" : "No matching record with Object of urn:uuid:12345 exists"
            }

## Lookup Relationships by Type [/relationships/{entityReferenceType}/{referenceUrn}/{type}{?view,reverse}]
### Lookup an array of all defined relationships of the specific type [GET]

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`
    + type (required, string `Owns`) ... Case-sensitive `type` of relationship to look for
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)
    + reverse (optional, boolean, `false`) ... Flips the query around, finding those relationships where the `entityReferenceType` and `referenceUrn` are in the related fields(defalts to false)

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : RelationshipAccessed
            SnapBundle-View : Standard

    + Body

            [
                {
                    "urn": "urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d",
                    "entityReferenceType": "Object",
                    "referenceUrn" : "urn:uuid:12345",
                    "type" : "Owns",
                    "relatedEntityReferenceType": "Object",
                    "relatedReferenceURN" : "urn:uuid:54321",
                    "lastModifiedTimestamp" : 1390607277299,
                }
            ]

+ Response 204

+ Response 400 (application/json)

    + Body

            {
                "code" : -8,
                "message" : "No matching record with Object of urn:uuid:12345 exists"
            }


# Group Geospatial Endpoints
## Overview
SnapBundle™ fully supports the [GeoJSON 1.0 Specification](http://geojson.org/geojson-spec.html). This powerful specification 
allows develoeprs to _fully_ define georectified shapes for any object managed by the platform.

The design is similar to popular social media sites that offer check-in capabilities. It is reasonble to define a single 
georectified entity and then create multiple relationships, such as check-ins, etc. (Remember, the relationship type is an 
arbitrary String, so a relationship type of "Check-In" could be arbitrarily defined by the developer)

## Geospatial Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
account | IAccount  | true | fase | Full | Generated
name | String  | true | true | Minimum |
description | String  | false | true | Standard |
activeFlag | Boolean  | true | false | Standard  |
geometricShape | GeometricShape | true | true | Minimum | 
type | String | true | true | Minimum | 


### Field Notes
- The `geometricShape` field fully contains the georectified shape definition.
- The `type` field is available to create an ontology or high level categories that can be used to group related interactions. 
The platform makes no inferences about this case-sensitive field.

## Geospatial Management [/geospatial]
### Define a geospatial entry [PUT]

The following fields may be used to create a new record:

- `name` is required and constrained to 255 characters
- `description` is optional and constrained to 1024 characters and may be omitted; defaults to **null**
- `activeFlag` is optional and may be omitted; defaults to **true**
- `geometricShape` is required and constrained to a valid GeometricShapeType value defined in 
[data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Data Types")
- `type` is required and constrained to 255 characters
- `moniker` is optional and constrained to 2048 characters may be omitted; defaults to **null**

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "name" : "Campus at 5th Street",
                "type" : "Building",
                "geometricShape" :
                    {
                      "type": "FeatureCollection",
                      "features": [{
                        "type": "Feature",
                        "geometry": {
                          "type": "Polygon",
                          "coordinates": [[
                            [13.42634, 52.49533],
                            [13.42660, 52.49524],
                            [13.42619, 52.49483],
                            [13.42583, 52.49495],
                            [13.42590, 52.49501],
                            [13.42611, 52.49494],
                            [13.42640, 52.49525],
                            [13.42630, 52.49529],
                            [13.42634, 52.49533]
                          ]]
                        },
                        "properties": {
                          "color": "rgb(255,200,150)",
                          "height": 150
                        }
                      }, {
                        "type": "Feature",
                        "geometry": {
                          "type": "Polygon",
                          "coordinates": [[
                            [13.42706, 52.49535],
                            [13.42675, 52.49503],
                            [13.42694, 52.49496],
                            [13.42678, 52.49480],
                            [13.42657, 52.49486],
                            [13.42650, 52.49478],
                            [13.42686, 52.49466],
                            [13.42714, 52.49494],
                            [13.42692, 52.49501],
                            [13.42717, 52.49525],
                            [13.42741, 52.49516],
                            [13.42745, 52.49520],
                            [13.42745, 52.49520],
                            [13.42706, 52.49535]
                          ]]
                        },
                        "properties": {
                          "color": "rgb(180,240,180)",
                          "height": 130
                        }
                      }, {
                        "type": "Feature",
                        "geometry": {
                          "type": "MultiPolygon",
                          "coordinates": [
                            [[
                              [13.42746, 52.49440],
                              [13.42794, 52.49494],
                              [13.42799, 52.49492],
                              [13.42755, 52.49442],
                              [13.42798, 52.49428],
                              [13.42846, 52.49480],
                              [13.42851, 52.49478],
                              [13.42800, 52.49422],
                              [13.42746, 52.49440]
                            ]],
                            [[
                              [13.42803, 52.49497],
                              [13.42800, 52.49493],
                              [13.42844, 52.49479],
                              [13.42847, 52.49483],
                              [13.42803, 52.49497]
                            ]]
                          ]
                        },
                        "properties": {
                          "color": "rgb(200,200,250)",
                          "height": 120
                        }
                      }, {
                        "type": "Feature",
                        "geometry": {
                          "type": "Polygon",
                          "coordinates": [[
                            [13.42857, 52.49480],
                            [13.42853, 52.49476],
                            [13.42863, 52.49473],
                            [13.42821, 52.49428],
                            [13.42837, 52.49423],
                            [13.42882, 52.49469],
                            [13.42896, 52.49465],
                            [13.42850, 52.49419],
                            [13.42867, 52.49412],
                            [13.42918, 52.49465],
                            [13.42857, 52.49480]
                          ]]
                        },
                        "properties": {
                          "color": "rgb(150,180,210)",
                          "height": 140
                        }
                      }]
                    }
            }
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : GeospatialEntryDefined

    + Body
    
            {
                "code" : 1,
                "message" : "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8"
            }
            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: type"
            }

### Update an existing geospatial entry [POST]

The request body must include a valid `urn` field. Only those fields being updated need to be included in the 
JSON body. For example, if you only want to update the `name` of the entry, only include that field in the 
request body.

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
    + Body
    
            {
                "urn": "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8",
                "name": "Columbus Campus"
            }
            
+ Response 204

    + Headers

            SnapBundle-Event : GeospatialEntryUpdated    

            
+ Response 400 (application/json)

    + Body
    
            {
                "code" : -5,
                "message" : "JSON is missing a required field: urn"
            }
            
            
## Lookup Matching Geospatial Entries [/geospatial{?view,nameLike}]
### Lookup an array of matching geospatial entries [GET]

If no `nameLike` query parameter is included, then all interactions are returned.

+ Parameters
    + nameLike (optional, string, `Campus`) ... A case-sensitive *starts with* string pattern to match against. If omitted, 
    then all records will be returned.
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : GeospatialEntryAccessed
            SnapBundle-View : Standard
            
    + Body
    
            [
                {
                    "urn": "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8",
                    "lastModifiedTimestamp": 1390779082063,
                    "name" : "Campus at 5th Street",
                    "description" : null,
                    "activeFlag" : true,
                    "type" : "Building",
                    "geometricShape" :
                        {
                          "type": "FeatureCollection",
                          "features": [{
                            "type": "Feature",
                            "geometry": {
                              "type": "Polygon",
                              "coordinates": [[
                                [13.42634, 52.49533],
                                [13.42660, 52.49524],
                                [13.42619, 52.49483],
                                [13.42583, 52.49495],
                                [13.42590, 52.49501],
                                [13.42611, 52.49494],
                                [13.42640, 52.49525],
                                [13.42630, 52.49529],
                                [13.42634, 52.49533]
                              ]]
                            },
                            "properties": {
                              "color": "rgb(255,200,150)",
                              "height": 150
                            }
                          }, {
                            "type": "Feature",
                            "geometry": {
                              "type": "Polygon",
                              "coordinates": [[
                                [13.42706, 52.49535],
                                [13.42675, 52.49503],
                                [13.42694, 52.49496],
                                [13.42678, 52.49480],
                                [13.42657, 52.49486],
                                [13.42650, 52.49478],
                                [13.42686, 52.49466],
                                [13.42714, 52.49494],
                                [13.42692, 52.49501],
                                [13.42717, 52.49525],
                                [13.42741, 52.49516],
                                [13.42745, 52.49520],
                                [13.42745, 52.49520],
                                [13.42706, 52.49535]
                              ]]
                            },
                            "properties": {
                              "color": "rgb(180,240,180)",
                              "height": 130
                            }
                          }, {
                            "type": "Feature",
                            "geometry": {
                              "type": "MultiPolygon",
                              "coordinates": [
                                [[
                                  [13.42746, 52.49440],
                                  [13.42794, 52.49494],
                                  [13.42799, 52.49492],
                                  [13.42755, 52.49442],
                                  [13.42798, 52.49428],
                                  [13.42846, 52.49480],
                                  [13.42851, 52.49478],
                                  [13.42800, 52.49422],
                                  [13.42746, 52.49440]
                                ]],
                                [[
                                  [13.42803, 52.49497],
                                  [13.42800, 52.49493],
                                  [13.42844, 52.49479],
                                  [13.42847, 52.49483],
                                  [13.42803, 52.49497]
                                ]]
                              ]
                            },
                            "properties": {
                              "color": "rgb(200,200,250)",
                              "height": 120
                            }
                          }, {
                            "type": "Feature",
                            "geometry": {
                              "type": "Polygon",
                              "coordinates": [[
                                [13.42857, 52.49480],
                                [13.42853, 52.49476],
                                [13.42863, 52.49473],
                                [13.42821, 52.49428],
                                [13.42837, 52.49423],
                                [13.42882, 52.49469],
                                [13.42896, 52.49465],
                                [13.42850, 52.49419],
                                [13.42867, 52.49412],
                                [13.42918, 52.49465],
                                [13.42857, 52.49480]
                              ]]
                            },
                            "properties": {
                              "color": "rgb(150,180,210)",
                              "height": 140
                            }
                          }]
                        }
                }
            ]
            
+ Response 204 


## Lookup Specific Geospatial Entity by URN [/geospatial/{urn}{?view}]
### Lookup a specific geospatial entity by its system-assigned URN key [GET]

+ Parameters
    + urn (required, string, `urn:uuid:66b7d3e9-69e1-499e-a867-9c4a939c6f7d`) ... System-assigned URN assigned at creation
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)

+ Request
    
    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/
            
+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : GeospatialEntryAccessed
            SnapBundle-View : Standard
            
    + Body
    
                {
                    "urn": "urn:uuid:95b995e2-dde5-4dd0-b50c-e804999411d8",
                    "lastModifiedTimestamp": 1390779082063,
                    "name" : "Campus at 5th Street",
                    "description" : null,
                    "activeFlag" : true,
                    "type" : "Building",
                    "geometricShape" :
                        {
                          "type": "FeatureCollection",
                          "features": [{
                            "type": "Feature",
                            "geometry": {
                              "type": "Polygon",
                              "coordinates": [[
                                [13.42634, 52.49533],
                                [13.42660, 52.49524],
                                [13.42619, 52.49483],
                                [13.42583, 52.49495],
                                [13.42590, 52.49501],
                                [13.42611, 52.49494],
                                [13.42640, 52.49525],
                                [13.42630, 52.49529],
                                [13.42634, 52.49533]
                              ]]
                            },
                            "properties": {
                              "color": "rgb(255,200,150)",
                              "height": 150
                            }
                          }, {
                            "type": "Feature",
                            "geometry": {
                              "type": "Polygon",
                              "coordinates": [[
                                [13.42706, 52.49535],
                                [13.42675, 52.49503],
                                [13.42694, 52.49496],
                                [13.42678, 52.49480],
                                [13.42657, 52.49486],
                                [13.42650, 52.49478],
                                [13.42686, 52.49466],
                                [13.42714, 52.49494],
                                [13.42692, 52.49501],
                                [13.42717, 52.49525],
                                [13.42741, 52.49516],
                                [13.42745, 52.49520],
                                [13.42745, 52.49520],
                                [13.42706, 52.49535]
                              ]]
                            },
                            "properties": {
                              "color": "rgb(180,240,180)",
                              "height": 130
                            }
                          }, {
                            "type": "Feature",
                            "geometry": {
                              "type": "MultiPolygon",
                              "coordinates": [
                                [[
                                  [13.42746, 52.49440],
                                  [13.42794, 52.49494],
                                  [13.42799, 52.49492],
                                  [13.42755, 52.49442],
                                  [13.42798, 52.49428],
                                  [13.42846, 52.49480],
                                  [13.42851, 52.49478],
                                  [13.42800, 52.49422],
                                  [13.42746, 52.49440]
                                ]],
                                [[
                                  [13.42803, 52.49497],
                                  [13.42800, 52.49493],
                                  [13.42844, 52.49479],
                                  [13.42847, 52.49483],
                                  [13.42803, 52.49497]
                                ]]
                              ]
                            },
                            "properties": {
                              "color": "rgb(200,200,250)",
                              "height": 120
                            }
                          }, {
                            "type": "Feature",
                            "geometry": {
                              "type": "Polygon",
                              "coordinates": [[
                                [13.42857, 52.49480],
                                [13.42853, 52.49476],
                                [13.42863, 52.49473],
                                [13.42821, 52.49428],
                                [13.42837, 52.49423],
                                [13.42882, 52.49469],
                                [13.42896, 52.49465],
                                [13.42850, 52.49419],
                                [13.42867, 52.49412],
                                [13.42918, 52.49465],
                                [13.42857, 52.49480]
                              ]]
                            },
                            "properties": {
                              "color": "rgb(150,180,210)",
                              "height": 140
                            }
                          }]
                        }
                }

+ Response 204 

# Group Metadata Endpoints
## Overview
SnapBundle provides an extremely flexible way to capture type-safe key-value pairs in order to capture a complete
representation of an object. The system uses either a built-in (opaque to the developer) encoding mechanism to ensure
type-safety, or alternatively a developer defined encoding mechanism (opaque to the platform) encoding
mechanism. The primitive data types supported by the built-in (opaque to the developer) encoding include:

   * **String**
   * **Date**
   * **Integer**
   * **Long**
   * **Boolean**
   * **Float**
   * **Double**

Each of these primitive data types guarantee a precision described by the Java Language Specification. In addition to
these primitives, the following two complex data types are also supported by the built-in (opaque to the developer)
encoding:

   * **JSON**
   * **XML**

Internally, these are stored as Strings but the declaration of the more formal type may provide a more convenient client
binding mechanism.

Finally, the platform also supports a **Custom** encoding (opaque to the platform) where the developer assumes full
responsibility for the serialization and deserialization of a type-safe value for the key.

> Built-in platform encoding must be treated as an opaque encoding. It presently relies on a 3rd party open-source
library (Jackson Data Binding). There is no current vision to replace this library, but if a more compact encoding is
discovered the existing approach may be replaced. If you don't want to rely on platform encoding, then you are free
to craft your own custom representation as described.

Generally speaking, if the `rawValue` is going to be over several kilobytes in size, developers are **strongly** encouraged
to store the data in a more efficient manner: as a File. The default implementation is to store the `rawValue` as a byte
array, but because JSON doesn't provide a byte array data type, values are explicitly encoded, thus expanding the overall
storage space. The maximum encoded `rawValue` size is 64K. To emphasize the point, that doesn't mean one could successfully
store a 64K String due to the encoded expansion that would need to occur.

> The `rawValue` should never be generated by hand unless the MetaDataType is specified as `Custom`.

The `Custom` MetaDataType places the onus entirely on the developer to provide a meaningful encoding/decoding capability!
One common use of `Custom` is when developers are relying on a serialization framework like Google's Protocol Buffers or
Hessian binary web service protocol.


## Metadata Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | false | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
entityReferenceType | EntityReferenceType | true | false | Minimum |
referenceURN | String | true | false | Minimum |
dataType | MetadataDataType | true | false | Minimum |
key | String  | true | true | Minimum |
rawValue | String  | true | true | Minimum  | Opaque Base64 encoded value when using built-in encoding

### Field Notes
- The `rawValue` field MUST be serialized and deserialized using the endpoints documented below *unless* a **Custom**
`dataType` value is assigned.


## Type-Safe Encoding [/metadata/mapper/encode/{metadataDataType}]
### Encodes a strongly typed value using the platform's built-in (opaque to the developer) encoded  [POST]

The body of the HTTP POST must contain a valid String representation of the specified `metadataDataType` specified.

- **200 SUCCESS_OK** the value was within the range of the specified `metadataDataType` and has been successfully
encoded

+ Parameters
    + metadataDataType (required, MetadataDataType, `BooleanType`) ... Valid MetadataDataType enum value

+ Request (text/plain)

    + Body

            true

+ Response 200 (application/json)

    + Body

            {
                "rawValue" : "AQ=="
            }

+ Response 400 (application/json)

    + Body

            {
                "code" : 0,
                "message" : "Unsupported MetadataType: foo"
            }

## Type-Safe Decoding [/metadata/mapper/decode/{metadataDataType}]
### Decodes a strongly typed value previously encoded using the platform's built-in (opaque to the developer) encoder [POST]

The body of the HTTP POST must contain a valid String representation of a platform encoded value of the type
`metadataDataType` specified.

> Generally, most developers will just take the entire metadata JSON record and POST it for value decoding, although only
the `rawValue` and `dataType` fields are mandatory.

- **200 SUCCESS_OK** the value was within the range of the specified `metadataDataType` and has been successfully
decoded

+ Request (application/json)

    + Body

            {
               "dataType": "BooleanType",
               "rawValue": "AQ==",
            }

+ Response 200 (application/json)

    + Body

            {
                "decodedValue" : true
            }

+ Response 400 (application/json)

    + Body

            {
                "code" : 0,
                "message" : "Unsupported MetadataType: foo"
            }

## Metadata Upsertion [/metadata/{entityReferenceType}/{referenceUrn}]
### Inserts a new key-value or updates an existing key value related to the specified entity [PUT]

This endpoint uses an **upsert** algorithm, inserting the metadata record(s) if the named key doesn't already exist, or
updating the value (and only the value) of the metadata record if the key already exists.

This endpoint expects the submission of a JSON array. The design allows for the rapid definition of multiple metadata
key-value pairs in a single operation. Each array entry must include a `key`, `dataType`, and a properly
encoded `rawValue` field.

> Metadata values are restricted to *an encoded representation* that is no more than
4K in size. If you were to encode a 4K string, the resulting encoding would be too large for the field. Instead,
large values should use a file instead of metadata.

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`

+ Request (application/json)

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

    + Body

            [
               {
                  "dataType": "BooleanType",
                  "key": "alpha",
                  "rawValue": "AQ=="
               },
               {
                  "dataType": "Custom",
                  "key": "foo",
                  "rawValue": "KioqKioqKioqKioqKg=="
               }
            ]

+ Response 200

    + Headers

            SnapBundle-Event : MetadataUpserted


+ Response 400 (application/json)

    + Body

            {
                "code" : -2,
                "message" : "No such URN"
            }

## Metadata Deletion [/metadata/{entityReferenceType}/{referenceUrn}/{key}]
### Deletes an existing metadata key by its system-assigned URN key [DELETE]

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`
    + key (required, string `alpha`) ... Case-sensitive `key` used to index the metadata raw value

+ Response 204

    + Headers

            SnapBundle-Event : MetadataDeleted

+ Response 400 (application/json)

    + Body

            {
                "code" : -2,
                "message" : "No such URN"
            }

## Lookup Associated Metadata [/metadata/{entityReferenceType}/{referenceUrn}{?view,key}]
### Lookup all metadata that matches the specified key pattern [GET]

+ Parameters
    + entityReferenceType (required, EntityReferenceType, `Object`) ... Valid EntityReferenceType enum value
    + referenceUrn (required, string, `urn:uuid:12345`) ... Case-sensitive `urn` of an existing entity of type `entityReferenceType`
    + view (optional, string, `Standard`) ... A valid JSON Serialization View name (case-sensitive)
    + key (optional, string, `alpha`) ... A valid, case-sensitive *startsWith* key name pattern. If omitted, then all key-values are returned.

+ Request

    + Headers

            Authorization: Basic eW91QGZvby5jb20gOiBOM3dzM2NyM3Q/

+ Response 200 (application/json)

    + Headers

            SnapBundle-Event : MetadataAccessed
            SnapBundle-View : Standard

    + Body

            [
               {
                  "dataType": "BooleanType",
                  "entityReferenceType": "Object",
                  "key": "alpha",
                  "lastModifiedTimestamp": 1393328943191,
                  "rawValue": "AQ==",
                  "referenceURN": "urn:FooBar:dae58c07-f92e-43ff-91aa-90a62e75b3ba",
                  "urn": "urn:uuid:47fe5a7d-1d0d-4c12-b256-96b970698623"
               },
               {
                  "dataType": "Custom",
                  "entityReferenceType": "Object",
                  "key": "foo",
                  "lastModifiedTimestamp": 1393328943205,
                  "rawValue": "KioqKioqKioqKioqKg==",
                  "referenceURN": "urn:FooBar:dae58c07-f92e-43ff-91aa-90a62e75b3ba",
                  "urn": "urn:uuid:5365e9f5-3eb4-492e-b2e0-95d57bc0662b"
               }
            ]

+ Response 204

+ Response 400 (application/json)

    + Body

            {
                "code" : -2,
                "message" : "No such URN"
            }

# Group File Endpoints
## Overview
The SnapBundle platform can associate *any* type of file with *any* of the platform's primary entity types. Furthermore,
there is no physical restriction on how many files may be associated with an object.

## File Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | false | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
entityReferenceType | EntityReferenceType | true | false | Minimum |
referenceURN | String | true | false | Minimum |
url | String | true | false | Restricted | Generated
mimeType | String | true | false | Minimum |
timestamp | long | true | false | Standard |
pending | Boolean | true | true | Full |
digitalSignature | String | true | false | Full |
fileName | String | true | false | Minimum |

### Field Notes
The `timestamp` differs from the `lastModifiedTimestamp` based on file creation time. In other words, the `timestamp`
should represent the creation time of the media, while the `lastModifiedTimestamp` will represent the time at which the
media was uploaded to the platform for storage. Please keep in mind that the creation time of the media is easily
manipulated in modern operating systems and may not be a truly accurate creation timestamp- this is beyond the control
of the platform and affects all software.

The combination of `entityReferenceType` and `referenceURN` links the File to be associated with any
[primary data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Primary Data Types"), including the
following:

   * Device
   * User
   * File
   * Metadata
   * Object
   * ObjectAddress
   * ObjectInteraction
   * ObjectInteractionSession
   * Relationship
   * Timeline
   * Georectification

The following arbitrary examples are intended to illustrate the power of this design:

   * A set of media could be associated with the Device, such as a picture of the actual laptop that shows its color, shape, etc.
   * A set of media could be associated with the User, such as the user's picture, their assigned company car, etc.
   * A set of media could be associated with an existing File definition, thus creating a nested tree of parent-child relationships.
   * A set of media could be associated with a piece of metadata, linking say the model year of the car associated with the VIN (stored in a Object record) with a PDF of the user manual for that year vehicle.
   * A set of media could be associated with an Object, showing what the object looks like, where it placed on its host, etc.
   * A set of media could be associated with an Object Address, showing what the building looks like from the outside.
   * A set of media could be associated with an Object Interaction, capturing additional context, like a video of the machine associated with the object actually started and running
   * A set of media could be associated with an Object Interaction Session, such as capturing a narrative about the location where the batch scan was initiated.
   * Etc.

> The delivery of a File is inherently a two-step process.

**First**, the actual database record (File) is defined. **Second**, the associated media file is physically uploaded to the SnapBundle™ platform. During the first operation, the File is marked as `pending = true` to indicate that the File record exists, but the actual file hasn't been physically uploaded to the cloud yet. After the file upload completes, the system automatically changes `pending = false` to indicate that the actual media is now available to the platform.

The `url` represents the physical URL of where the file is stored inside of the virtual file system (VFS). For security reasons, this URL isn't directly accessible and is therefore annotated as a Restricted field.

> The toggle of the `pending` flag to false is the only indication to an [Extension](EXTENSION_FRAMEWORK.md "Extension Framework") listening in on the Event Stream that the media is available for download. Instead of relying on the `pending` flag, integrators should instead look for the `FileUploaded` event (instead of `FileDefined`) for confirmation that the actual file is available for download.

> Developers must use the **PUT** endpoint to first define the File, then use one of the **POST** endpoints to physically
upload the file to the cloud for storage. The multi-part endpoint expects a multi-part mime type, while the octet
expects an octet-stream mime type.

If the file content already exists at a well-defined location on the web that can be referenced with an HTTP or HTTPS
URL, then the developer may optionally choose to include a `contentUrl` field in the **PUT** request. The platform checks
for the existence of `contentUrl` and `mimeType` fields, and if present, not-null, and the content is successfully
retrieved, then the **PUT** operation is self-contained. In this case, self-contained means that the **PUT** operation
generated the File record _and_ downloaded the content of the given MIME type from the referenced URL and placed it
into platform storage. If the `contentUrl` field is included with a `null` value or cannot be successfully downloaded,
or if the `mimeType` field is omitted, then an HTTP 400 status code will be returned to the developer to convey the fact
that file content is missing or inaccessible. This also means that the File record was _not_ saved either.


For retrieval, when requesting by `{entityReferenceType}/{referenceUrn}`, the system will always respond with a
JSON array, detailing the set of File definitions associated with the referenced object. In contrast, the `{urn}`
GET request represents the URN assigned to a specific File definition, returning the single JSON object defining
the given File.

** Endpoint Definitions To Be Documented **

Endpoint | Supported HTTP Methods | Events Generated
------------ | ------------- | ------------
/files | PUT  | FileDefined
/files/{urn}/octet | POST | FileUploaded
/files/{urn}/multipart | POST | FileUploaded
/files/{urn}/contents | GET | FileAccessed
/files/{urn} | GET | FileAccessed
/files/{entityReferenceType}/{referenceUrn} | GET | FileAccessed (for each file)
/files/{urn} | DELETE | FileDeleted

# Group Tag Endpoints
## Overview
Tags have grown in popularity across the Web for assigning quick search terms to everything from blog postings to
Twitter posts. The platform provides a Tag object for this purpose as well. The following data types support a Tag
association:

   * Device
   * File
   * Object
   * ObjectAddress
   * ObjectInteraction
   * ObjectInteractionSession
   * Georectification
   * Timeline
   * Relationship

## Tag Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | false | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
name | String  | true | true | Minimum |
description | String  | false | true | Standard |
activeFlag | Boolean  | true | true | Standard  | true

### Defining a Tag
Tag definition can occur in two different ways: *explicitly* or *implicitly*. An explicit Tag definition occurs when a
Tag is defined by providing a name, description, and optional moniker value. The result of an explicit Tag definition
is a Tag but one that is *not assigned* to any object under the Account. In contrast, an implicit Tag definition occurs
when a Tag Assignment is made between a referential object, i.e. one of the supported data types listed above, and a
previously *undefined* tag name.

**NOTE:** Tag names, a.k.a. labels, are case-sensitive and Tag definition idempotent (you can explicitly define the same
Tag name 100 times, but the system will only store the first one).

### Deleting a Tag
**Deletion of a Tag requires the Administrator role.**
When a Tag is deleted, any Tag Assignment with a referential object that references that Tag name is automatically
deleted.

** Endpoint Definitions To Be Documented **

Endpoint | Supported HTTP Methods | Events Generated
------------ | ------------- | ------------
/tags | PUT  | TagUpserted
/tags/tag/{tagName} | DELETE | TagDeleted, TagRevoked
/tags/tag/{tagName} | GET | TagAccessed
/tags/{urn} | GET | TagAccessed
/tags/{entityReferenceType/{referenceUrn} | PUT | TagAssigned
/tags [?tagName=Foo&entityReferenceType=Bar&referenceUrn=Baaq] | GET | TagAccessed (for each tag)

**NOTE** The GET query parameters can be combined for flexible searching, like all tags with a name like Foo and of entity reference type Object, for example.

**NOTE** The PUT endpoint at */tags* is idempotent and will respond with a **201- SUCCESS_CREATED ** if the record is new, or a **200 - SUCCESS_OK** if a Tag with the given `name` already existed in the database (no data is merged; existing record is left as-is).

**NOTE:** The PUT endpoint at */tags/{entityReferenceType}/{referenceUrn}* expects a JSON Array.  The endpoint _automatically creates a Tag_ if the named Tag doesn't already exist. Submitting a single JSON object is not supported at this time. The following JSON Array could be PUT into the Tag assignment endpoint without any prior Tag related RESTful calls, and the result would be the automatic creation of two new Tag objects, alpha and bravo, and an association between those two Tag objects and the referenced entity defined in the URL.

````
[
    {
        "name": "alpha"
    },
    {
        "name": "bravo"
    }
]
````

# Group Extension Endpoints
## Overview
TO BE DOCUMENTED

# Group Notification Endpoints
## Overview
TO BE DOCUMENTED

**All notification endpoint URLs must rely on SSL/TLS by specifying an https:// address**.

# Group Event Stream Endpoints
## Overview
The SnapBundle platform captures and persists every user's activity stream. Creation, updates, reads and deletes are all
logged in their entirety into the database using a flexible *Event Stream* metaphor. This event stream literally is a
transaction log of *who* did *what*, *when*. The most common application for this event stream is to define one or more
**Notification Endpoints** to receive and process the event stream data in near real-time. These notification endpoints
can be used for back office integration, and more commonly, to feed one or more authorized **Extensions**, or 3rd party
plugins. Extensions provide an unlimited platform extension mechanism whereby expert algorithms can be fed the
event stream data to produce higher level intelligence (think "Big Data").

> Each Account may define as many dedicated event stream notification endpoints as they deem necessary.

As user activity occurs within an account, events are generated by the SnapBundle platform and first persisted to the
database, and then immediately dispatched to queue for relay to the notification endpoint.

> All events are, by design, immutable.


## Event Fields
Field | Data Type | Required | Can Update | Serialization Level | Default Value
------------ | ------------- | ------------ | ------------ | ------------ | ------------
urn | String  | true | false | Minimum | Generated
account | IAccount  | true | false | Full | Generated
lastModifiedTimestamp | long   | true | false | Standard | Generated
moniker | String  | false | true | Full | null
user | IUser | true | false | Minimum | Minimum |
eventType | EventType | true | false | Minimum |
source | String | true | false | Minimum |

The `lastModifiedTimestamp` represents the time the specified `user` performed the given `eventType`. The operation
performed must be contextually deduced from the `eventType` field. Each `eventType serializes the resulting object state
into the `source` field.

> With certain `eventType` values, the `user` and/or `source` fields may be null. For example, a *UserLoginFailure* will
never have a `user` object, since the login failed and no corresponding object could be definitively identified. In
another example, an *ObjectUpdated* event would put the authenticated user into the `user` field, and place the
resulting Object (as JSON) in the `source` field. By combining the `user`, `eventType`, and `source`, an Extension is
able to literally monitor the state of the Account's data in real time.

One last common example worthy of discussion surrounds the definition of a File. Recall that the
definition of a File is a two-stepped procedure. First, the File record is defined, with `pending = true` to indicate
that the physical media hasn't yet been uploaded to the cloud. This state is represented with the *FileDefined* event
type. If an Extension actually needs to retrieve the media from the SnapBundle platform, it must wait until the
*FileUploaded* event triggers, indicating that the file is now ready for download from the cloud. In fact, the
*FileUploaded* event's `source` will contain a JSON representation of the updated File that includes the `urn` that the
Extension can use to fetch the actual content.

> For a complete list of `EventType` values, please review the [primary data types](https://github.com/snapbundle/sdk/blob/master/DATA_TYPES.md "Primary Data Types") documentation.

## Event Endpoints
*Please contact us to discuss your needs for such endpoint(s).*

