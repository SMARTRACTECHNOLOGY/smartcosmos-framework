# Contextual Searching
The SnapBundle™ platform defines searches differently from a direct lookup. With a direct lookup, you know the exact key of the object you are interested in. The following endpoint provide either object-specific searching, i.e. searching for just Metadata or searching for just Tags, or they provide a powerful _search query_ capabilitiy.

> Searching endpoints are read-only operations and by design do not generate any events.

## File Searching Endpoints
Searches for all Files associated with a specific object.

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/files/query/{entityReferenceType}/{referenceUrn} | GET |

## Metadata Searching Endpoints
Searches for all Metadata associated with a specific object.

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/metadata/query/{entityReferenceType}/{referenceUrn} | GET

## Tag Searching Endpoints
Searches for objects assigned a specific tag identified by `name`. Specifying an `entityReferenceType` restricts the search to specific object entity types. Furthermore, specifying both an `entityReferenceType` and a `referenceUrn` queries for those tags assigned to the specific object.  

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/tags/query/{name} | GET
/app/tags/query/{name}/{entityReferenceType} | GET
/app/tags/query/specific/{entityReferenceType}/{referenceUrn} | GET

## Query String Search Endpoint
Performs a search across a single object type, e.g. _just_ Device objects. Be sure to use only the documented [EntityReferenceType](DATA_TYPES.md "EntityReferenceType") values.

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/search/{entityReferenceType} | GET

The query string may idicate either `name`, `nameLike`, `moniker`, or `monikerLike`. It is not possible with this endpoint to use combinations of these values. It is also possible, when searching for [User](USER.md "User") objects to use `emailLike` in the query string. 

> All queries may optionally include a `limit` parameter set to a positive integer value that restricts the number of matching rows returned.

## Object Interaction Search Endpoints
### (Search Criteria Driven)
The [Object Interaction](OBJECT_INTERACTION.md "Object Interaction") is hands-down the most powerful contextual primary data type in the SnapBundle™ platform. Every Object Interaction captures context:


**_This_** [User](USER.md "User") utilized **_this_** [Device](DEVICE.md "Device"") and interacted with **_this_** [Object](OBJECT.md "Object") at **_this_** time at **_this_** [geo-rectified address](OBJECT_ADDRESS.md "Object Address") and associated **_this_** set of [Files](FILE.md "File") along with **_this_** set of [Metadata](METADATA.md "Metadata") and **_this_** set of [Tags](TAG.md "Tag") to capture the moment, possibly in the context of other interactions within **_this_** [ObjectInteractionSession](OBJECT_INTERACTION_SESSION.md "ObjectInteractionSession").  

> This is the only search endpoint that relies on an **HTTP POST** operation!  

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/search/criteria/interaction | **POST**

The body of the POST is a JSON representation of a `SearchCriteria` object used to refine _exactly_ which ObjectInteraction records you want to retrieve.

## Event Searching Endpoints 
### (Search Criteria Driven)

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/search/criteria/events | POST

## Object Searching Endpoints 
### (Search Criteria Driven)

Endpoint | Supported HTTP Methods
------------ | ------------- 
/app/search/criteria/objects | POST

### Search Criteria
Search Criteria are comprised of 1 or more `SearchClause` objects, with each `SearchClause` object associated with a specific `EntityReferenceType`. In turn, each Search Clause is comprised of a `SearchField`, `SearchPredicated`, and value.

The `SearchField` is a large enum that restricts the queries to specific well-defined fields. Similarly, the `SearchPredicate` is a large enum that restricts the operation to basic comparison operations. Refer to the [Search Data Types](DATA_TYPES.md "Search Data Types") for more details on specific fields.

#### Pracital Examples
_I want to see the ObjectInteraction records generated by User foo with the Samsung Galaxy S4 that has an IMEI of 123456 with the last week._

````
{
   "target" : "ObjectInteraction",
   "criteriaMap" :
      {
         "User" :
            {
               "searchField" : "EmailAddress",
               "searchPredicate" : "STARTS_WITH",
               "value" : "foo"
            },
         "Device" :
            {
               "searchField" : "DeviceIdentification",
               "searchPredicate" : "EQUALS",
               "value" : 123456
            },
         "Object" :
            {
               "searchField" : "ReceivedTimestamp",
               "searchPredicate" : "AFTER",
               "value" : 1383274162825
            }
      },
   "limit" : 5
}
````
> Regardless if your solution is actually built using Java or not, developers are encouraged to use the Java library to build out their search criteria programmatically, echoing the JSON to the console until they are comfortable with the syntax.

Here's what the Java code looks like that generated this JSON object:

````
final long WITHIN_LAST_WEEK = System.currentTimeMillis() - TimeUnit.DAYS.toDays(7);

String json = SearchCriteria.newInstance(EntityReferenceType.ObjectInteraction)
.addCriteria(EntityReferenceType.User,
        SearchClause.newInstance()
                .field(SearchField.EmailAddress)
                .is(SearchPredicate.STARTS_WITH)
                .value("foo"))
.addCriteria(EntityReferenceType.Device,
        SearchClause.newInstance()
                .field(SearchField.DeviceIdentification)
                .is(SearchPredicate.EQUALS)
                .value(123456))
.addCriteria(EntityReferenceType.Object,
        SearchClause.newInstance()
                .field(SearchField.ReceivedTimestamp)
                .is(SearchPredicate.AFTER)
                .value(WITHIN_LAST_WEEK))
.setLimit(5)
.toJson();
````

While completely abstracted from the developer, it so happens that the JSON yields the following parameterized WHERE clause (to prevent SQL injection attacks):

````
m.user.emailAddress LIKE :param1 AND 
m.device.identification = :param2 AND 
m.object.receivedTimestamp >= :param3
````
Let's look at another Search Criteria example, this time with an Event search:
_I want to see the Event records generated by User's who have an email address that starts with foo ordered by email address in ascending order_

````
{
   "target" : "Event",
   "criteriaMap" :
      {
         "User" :
            {
               "searchField" : "EmailAddress",
               "searchPredicate" : "STARTS_WITH",
               "value" : "foo"
            }
      },
   "limit" : 5,
   "orderBy" :
      {
         "searchField" : "EmailAddress",
         "direction" : "Ascending"
      }
}
````

Here's what the Java code looks like that generated this JSON object:

````
String json = SearchCriteria.newInstance(EntityReferenceType.Event)
        .addCriteria(EntityReferenceType.User,
                SearchClause.newInstance()
                        .field(SearchField.EmailAddress)
                        .is(SearchPredicate.STARTS_WITH)
                        .value("foo"))
        .setOrderBy(OrderBy.newInstance()
                .field(SearchField.EmailAddress)
                .asc())
        .setLimit(5)
        .toJson();

````