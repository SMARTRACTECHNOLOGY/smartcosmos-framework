#set( $H = '#' )

$H This project was initially created by the SMART COSMOS Objects Extension Archetype

$H$H Maven Group ID: ${groupId}

$H$H Maven Artifact ID: ${artifactId}

$H$H Maven Version: ${version}

$H$H Java Top-Level Package: ${package}

$H$H Introduction

The SMART COSMOS Objects platform is thoroughly documented, offering developers well-planned learning paths at our
education portal, SMART COSMOS Lessons, available at http://lessons.smart-cosmos.com. There is also a vibrant partner
portal with white papers, business and developer profiles, contests, and more at http://partner.smart-cosmos.com.

What follows is merely brief description of what functionality is covered by the examples generated by the archetype.
As you read through the code, pay special attention to comments that start with the string NOTE TO EXTENSION DEVELOPER:

$H$H Creating a Visitor

For a general introduction to the Visitor pattern, see Design Patterns [GoF] or Wikipedia.
The basic idea is this context is that by registering a visitor for a particular SMART COSMOS Objects element type,
you can inject functionality that is executed whenever an element of this type is created or updated.

$H$H$H Creating the Visitor Class

For a complete description see: https://smartractechnology.atlassian.net/wiki/pages/viewpage.action?pageId=25493632

Visitors can be added to any of the following entity types:

Device
Event
File
Georectification
Metadata
Relationship
Object
ObjectAddress
ObjectInteraction
ObjectInteractionSession
Tag
Timeline

Look in the directory ${package}.visitor, and you'll see three examples of visitor classes.

Read through the source code (they're very short) and be conscious of the following:

- Your class must extend AbstractVisitor<VisitableEntityType>, where VisitableEntityType is the type of entity on which,
when an entity of this type is created or updated, you want the visit method invoked.
- The first argument of the super constructor must be unique, and must be a String representation of a java.util.UUID.
DO NOT USE THE PROVIDED DEFAULT! Generate your own, with the following:
```java
java.util.UUID.randomUUID().toString()
```
and replace the String in the first argument with that. YOU MUST DO THIS FOR EVERY VISITOR! EVERY VISITOR REQUIRES ITS 
OWN UNIQUE ID!

$H$H$H Registering the Visitor Class

Look in src/main/resources/objects.yml, and find the "visitors:" section.
It's as simple as that. The names must be unique. To remove the example visitors, comment out those lines.
If you are using no visitors, comment out the "visitors:" line as well.

$H$H$H About Priorities

Every visitor has a priority between 1 (highest possible priority) and 100 (lowest possible priority). These can be 
assigned in your visitor's super constructor, like:

```java
super("9D87E521-B5A4-4136-B42D-75A19A4C4ABD", "Happy Birthday Fred Object Visitor Service",
      EntityReferenceType.Object, 90);
```

where the last argument is the priority. If you use the super constructor

```java
super("9D87E521-B5A4-4136-B42D-75A19A4C4ABD", "Happy Birthday Waldo Object Visitor Service",
      EntityReferenceType.Object);
```
i.e, not explicitly assigning a priority, the visitor will be assigned a priority of 50. If multiple visitors for a 
particular entity type have the same priorities, the order in which they will be executed is indeterminate.

Note also that the priority numbers stored in the actual visitor registration table are not the priorities you assign 
(in order to support multiple visitors with the same priority assignments), so don't be surprised if you see very large 
priority values in the debugger. The ordering will be correct.

Using visitors in SMART COSMOS Objects is thoroughly documented here: 

https://smartractechnology.atlassian.net/wiki/display/SCKB/Using+Visitors+in+SMART+COSMOS

$H$H Creating Data Entities and Access Points

Important note: You do not have to instantiate tables in your backing data store. SMART COSMOS only requires that a 
database exists at the location and with the username/password combination specified in objects.yml. This is described 
in more detail in the top-level README here:

https://github.com/SMARTRACTECHNOLOGY-PUBLIC/smartcosmos-extension-archetype

NOTE TO READER: The above URL is not public yet. I'll remove this line when it is.

A database table is represented in the SMART COSMOS world as an Entity, and annotated as javax.persistence.Entity.
Any field with a getter and a setter not otherwise annotated becomes a database column of the type Hibernate considers
closest to the Java type. To customize this, use the JPA @Column annotation. To create foreign keys, use the standard
javax.persistence annotations.
 
All Entity classes must extend from (some subclass of) net.smartcosmos.platform.jpa.base.DomainResourceEntity, and thus 
inherit the minimal features of a SMART COSMOS entity: a unique system UUID, a URN derived from it (not actually stored 
in the database, since it's completely determined by the system UUID), a lastModifiedTimestamp, and a Moniker.

This is what you get when you extend from net.smartcosmos.platform.jpa.base.DomainResourceEntity.
If you want your entity to have an owning account, extend from: 

*net.smartcosmos.platform.jpa.base.DomainResourceAccountEntity*

If you want your entity to have a non-null name, a description, and an active flag, extend from:

*net.smartcosmos.platform.jpa.base.DomainResourceNamedObjectEntity*

If you want your entity to have all of the above (as every entity in the core of SMART COSMOS does), extend from: 

*net.smartcosmos.objects.jpa.base.DomainResourceAccountNamedEntity*

To add a type string to the above, extend from:

*net.smartcosmos.objects.jpa.base.DomainResourceAccountTypedNamedEntity*

Many entities in core SMART COSMOS (Metadata, File, ObjectInteraction, ...) have the concept of an entityReferenceUrn 
and an EntityReferenceType, and this is the mechanism by which, for example, a metadata item (containing, basically, a 
key-value pair) is associated with another entity, typically but not necessarily an Object. To create an entity which 
contains an entityReferenceUrn and an EntityReferenceType,, extend from either 
net.smartcosmos.objects.jpa.base.DomainResourceReferentialObjectEntity or 
net.smartcosmos.objects.jpa.base.DomainResourceAccountNamedReferentialObjectEntity, depending on your additional needs.

There are two example entity classes in this project. The first is:

*${package}.jpa.impl.ExampleEntity*

and is a very simple extension of DomainResourceEntity which creates two String columns. The second is:
 
*${package}.jpa.impl.MoreInterestingExampleEntity*

which extends DomainResourceReferentialObjectEntity, and thus requires that you provide a referenceUrn and a 
referenceEntityType when inserting a MoreInterestingExampleEntity in the database. Read through these to get a feel for 
how to build entities in SMART COSMOS Objects.

As an exercise, you could modify ExampleEntity to extend DomainResourceReferentialObjectEntity, and 
MoreInterestingExampleEntity to extend DomainResourceAccountNamedReferentialObjectEntity, to see what that does to the 
generated database tables, and what additional requirements it implies for insertions and updates into these tables.


$H$H$H Creating a Data Access Object (DAO)

There's not much to explain here; the examples should tell you what you need to know. Don't do any work that isn't 
already done for you - make sure you look through net.smartcosmos.platform.dao.AbstractDAOImpl and 
net.smartcosmos.platform.api.dao.IBaseDAO before adding any methods, so you know what the SMART COSMOS platform 
provides. It could well be the case that the method you need is already in place, or that you could assemble it more 
quickly using methods that are already in place.

Pay attention to the packaging, and keep your interfaces in ${package}.dao, 
and implementations in ${package}.dao.impl. And use the interfaces in 
request handlers; there are many examples in this code.

$H$H$H Creating a REST Web Service Endpoint

So now we have a couple of example entities, and Data Access Object (DAO) interfaces and implementations for doing 
operations on them, including the normal CRUD operations we inherit from the platform, and two extra find methods: 

findByFirstString()
findByBothStrings()

We have access to these methods via REST endpoints. What if I want to add, say, an additional metadata endpoint, one 
that provides my users with the option of getting all metadata for a particular referenceUrn and of for a particuar 
type value? Actually, this endpoint already exists (GET /rest/metadata/{entityReferenceType}/{referenceUrn}/{?view,key},
which you can read about in the SMART COSMOS documetation), but it's a good example.

It's no different than int the above examples, except that you don't have to create the entity. Create the resource 
(say, ExtensionMetadataResource.java), create DAO interfaces and implementations (say, IExtensionMedataDAO.java 
extending IBaseDAO<Metadata> and ExtensionMetadataDAOImpl.java extending AbstractDAOImpl<IMetadata, MetadataEntity> and 
implementing IMetadataDAO). Register the endpoints in ExampleExtensionEndpointsResourceRegistrar.java as we
did with the examples above, and the DAO in the registerResources() method of ExampleExtension.java, as did with the 
examples above. Restart the server, and the new endpoints should be available.

$H$H$H Controlling Access to REST Endpoints

Look in src/main/resources/objects.yml, and you will see two sections that relate to access control for endpoints. 
The first looks something like:

    #
    # Master control flags for enabling/disabling various Objects endpoints
    #
    endpoints:
      metadataEncodingEndpoints : true
      eventsEndpoint : true
      objectAddressEndpoint : true
      deviceEndpoints : true
      metadataEndpoints : true
    ...

With these flags you can disable entire categories of core Objects functionality. Set "deviceEndpoints" to "false", and 
none of the device endpoints will even be loaded, and will return a 404 Not Found if invoked. These flags only apply, 
though, to core Objects endpoints. Endpoints which are registered as part of an extension can be found in the
objects.yml: 

    exampleEndpointsRegistrar: com.example.smartcosmos.server.extension.example.ExampleExtensionEndpointsResourceRegistrar

This is the line that registers the example endpoints; ; if you want to turn them off just comment out the line 
containing their EndpointResourceRegistrar.

The second looks like:

    # 
    #  Master endpoint method enablement flags. When endpoint method is set to 'true' then that specific
    #  HTTP Method is supported on a given endpoint. These flags contrast from the 'endpoints' flags above
    #  in that they are HTTP METHOD oriented whereas the above 'endpoints' section is an 'all or nothing' flag.
    #  If the 'endpoints' flag is set to false, then the endpoint HTTP METHOD flags below HAVE NO EFFECT since
    #  the entire endpoint has been disabled. In other words, the flags below only are applicable if the overall
    #  endpoint is enabled.
    # 
    endpointMethodControl:
      realm.get : true
      register.post : true

      account.get : true
      account.post : true
      account.password.change.post : true
      account.password.reset.post : true

      users.put : true
      users.post : true
      users.urn.get : true
      users.user.get : true
      users.user.post : true

      devices.put : true
      devices.post : true
      devices.urn.get : true
      devices.device.get : true
      devices.get : true

    ...

      extension.example.putTwoStrings : true
      extension.example.findByFirstString : true
      extension.example.findByBothStrings : true

      extension.moreInterestingExample.moreInterestingPutTwoStrings : true
      extension.moreInterestingExample.moreInterestingFindByFirstString : true
      extension.moreInterestingExample.moreInterestingFindByBothStrings : true


Two things about this:

1. These flags can be used on extension endpoints; just add them to your objects.yml file. Note that if endpoints
reference here to not have a corresponding string in the @EndpointMethodControl annotation of the appropriate resource
method, a warning will be logged, but the method will be invoked.

2. In Objects core, these flags are used to e.g., turn off all the PUT methods for a particular piece of the API.
Every PUT method in Objects carries the

@EndpointMethodControl(key = "objects.put")

annotation. You can, as in the example above, be more fine-grained if you need to, and set these flags for individual 
methods, as I've done in the examples above (see also the @EndpointMethodControl annotations in the *Resource.java files 
themselves).

Creating data entities and access points is thoroughly documented here:

https://smartractechnology.atlassian.net/wiki/display/SCKB/Creating+Data+Entities+and+Access+Points+in+SMART+COSMOS


$H$H Creating a Transaction Handler


There are two parts to creating a transaction handler: writing the code itself, and declaring it in the configuration.

First, the configuration, since it's simple. In your objects.yml file, you see the following:

$H$H$H Configuration

	transactionHandlerClasses:
  		myExampleTransactionHandler: ${package}.resource.secure.transaction.handlers.ExampleTransactionHandler

That's it for the configuration. When you specify the name of the transaction handler in the rest call 
(PUT /rest/transaction/myExampleTransactionHandler), the JSON body will be passed intact to the run() method of the 
handler, as described below.


$H$H$H The Code

In the example transaction handler, ${package}.resource.secure.transaction.handlers.ExampleTransactionHandler.java,
notice the following:

There are only one constructor and two methods. As elsewhere, you'll need to create your own UUID to use as a serviceID 
in the constructor. On to the methods:

initialize() is available if you need it, but you probably won't.

run() is where the action is. The txUuid (transaction UUID) field is generated by the platform, and is there for 
logging purposes. The first parameter, fatJson, is the string representation of the JSON payload of the request. In this 
example, the payload will look something like this:

	{
		"objects":[
		{
			"objectUrn": "urn:transactional:Test1",
			"type": "transo",
			"name": "Test1",
			"moniker": "a moniker for Test1",
			"description": "a description"
		},
		{
			"objectUrn": "urn:transactional:Test2",
			"type": "transo",
			"name": "Test2",
			"moniker": "a moniker for Test2",
			"description": "another description"
		},
		{
			"objectUrn": "urn:transactional:Test3",
			"type": "transo",
			"name": "Test3",
			"moniker": "a moniker for Test3",
			"description": "yet another description"
		}
	}

The run() method creates a JsonNode from the input string, extracts the "objects" element, verifies that it's an array, 
and loops through the array, and inserts (WELL, NOT REALLY) the individual object elements into the database.

$H$H$H$H What does WELL, NOT REALLY mean?

It means that the entire method is wrapped in a database transaction, and if any operation fails, all of the elements 
in the entire transaction will be rolled back. Every call to the /rest/transaction/myExampleTransactionHandler is a 
unit of work - either everything in the input JSON body makes it into the database, or nothing does.

One other thing to notice about the transaction handler: unlike other request handlers, it does not build a Response 
under any circumstances. The platform takes care of that for you. If everything is good at the end of processing your 
incoming JSON, return quietly from the run() method (after flushing and clearing the Hibernate session, as in the 
example). If anything goes wrong and you want to roll back the entire transaction, throw a 
net.smartcosmos.platform.util.TransactionException, and the platform will clean up.

$H$H$H A Last Note

Transaction handlers are very powerful, and with great power comes great responsibility. Be careful, and if you're not  
sure something is valid, throw the TransactionException.

Creating and using transaction handlers is very thoroughly documented here:

https://smartractechnology.atlassian.net/wiki/display/SCKB/Creating+and+Using+Transaction+Handlers+in+SMART+COSMOS

